const childProcess = require('child_process');
const fs = require('fs');
const SUPPORTED_TABLES = ['filter', 'nat', 'mangle', 'raw'];
const IPTABLES_SAVE_PATH = '/etc/iptables';

class Iptables {
    constructor(debug) {
        this.debug = debug;
    }

    // Chains
    async listChains(table = 'filter', ip6 = false) {
        const output = await this.executeIptables(['-t', table, '-S'], ip6);
        const chains = [];
        loop: for(const line of output.split('\n')) {
            const parts = line.split(' ');
            switch(parts[0]) {
                case '-P':
                    chains.push({
                        name: parts[1],
                        system: true,
                        defaultPolicy: parts[2]
                    });
                    break;
                case '-N':
                    chains.push({
                        name: parts[1],
                        system: false
                    });
                    break;
                default:
                    break loop;
            }
        }
        return chains;
    }
    async addChain(name, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-N', name], ip6);
    }
    async deleteChain(name, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-F', name], ip6);
        await this.executeIptables(['-t', table, '-X', name], ip6);
    }
    async renameChain(oldName, newName, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-E', oldName, newName], ip6);
    }
    async setDefaultPolicy(chainName, value, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-P', chainName, value], ip6);
    }

    // Rules
    async listRules(chain, table = 'filter', ip6 = false) {
        const output = await this.executeIptables(['-t', table, '-S', chain], ip6);
        const rules = [];
        for(const line of output.split('\n')) {
            const parts = line.split(' ');
            if(parts[0] == '-A') {
                parts.shift();
                parts.shift();
                rules.push(parts.join(' '));
            }
        }
        return rules;
    }
    async getRule(chain, index, table = 'filter', ip6 = false) {
        const output = await this.executeIptables(['-t', table, '-S', chain, index], ip6);
        const parts = output.trim().split(' ');
        parts.shift();
        parts.shift();
        return parts.join(' ');
    }
    async addRule(chain, value, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-A', chain, ...this.splitRule(value)], ip6);
    }
    async insertRule(chain, index, value, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-I', chain, index, ...this.splitRule(value)], ip6);
    }
    async deleteRule(chain, index, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-D', chain, index], ip6);
    }
    async editRule(chain, index, newValue, table = 'filter', ip6 = false) {
        await this.executeIptables(['-t', table, '-R', chain, index, ...this.splitRule(newValue)], ip6);
    }
    async moveRule(chain, oldIndex, newIndex, table = 'filter', ip6 = false) {
        if(oldIndex == newIndex) return;
        const rule = await this.getRule(chain, oldIndex, table, ip6);
        await this.deleteRule(chain, oldIndex, table, ip6);
        await this.insertRule(chain, newIndex, rule, table, ip6);
    }

    // Save & restore
    async restoreRules(flush = true) {
        const args = [];
        if(!flush) args.push('--noflush');
        args.push(IPTABLES_SAVE_PATH+'/rules.v4');
        await this.executeCommand('iptables-restore', args);
        args.pop();
        args.push(IPTABLES_SAVE_PATH+'/rules.v6');
        await this.executeCommand('ip6tables-restore', args);
    }
    async saveRules(excludedChains = []) {
        let content = await this.generateSaveFile(excludedChains, false);
        await fs.promises.writeFile(IPTABLES_SAVE_PATH+'/rules.v4', content);

        content = await this.generateSaveFile(excludedChains, true);
        await fs.promises.writeFile(IPTABLES_SAVE_PATH+'/rules.v6', content);
    }
    async generateSaveFile(excludedChains = [], ip6 = false) {
        let out = `# Generated by iptables-web-ui on ${new Date().toISOString()}\n`;
        for(const table of SUPPORTED_TABLES) {
            out += `\n*${table}\n`
            const output = await this.executeIptables(['-t', table, '-S'], ip6);
            let prevChain;
            for(const line of output.split('\n')) {
                if(!line) continue;
                const parts = line.match(/^-(\w) (.+?)(?:$| (.+))/);
                const type = parts[1], chain = parts[2], value = parts[3];

                if(excludedChains.includes(ip6+'-'+table+'-'+chain)) continue;
                switch(type) {
                    case 'P':
                        out += `:${chain} ${value} [0:0]\n`;
                        break;
                    case 'N':
                        out += `:${chain} - [0:0]\n`;
                        break;
                    case 'A':
                        if(prevChain != chain) out += `\n# Chain ${chain}\n`;
                        out += line+'\n';
                        break;
                }
                prevChain = chain;
            }
            out += 'COMMIT\n\n';
        }
        return out;
    }

    executeIptables(args, ip6) {
        return this.executeCommand(ip6 ? 'ip6tables' : 'iptables', args);
    }
    executeCommand(cmd, args) {
        return new Promise((resolve, reject) => {
            const arpscan = childProcess.spawn(cmd, args);
            if(this.debug) console.log(cmd+' '+args.join(' '));
           
            let buffer = '', errbuffer = '';
            arpscan.stdout.on('data', data => buffer += data);
            arpscan.stderr.on('data', data => errbuffer += data);
    
            arpscan.on('close', code => {
                if(code != 0) {
                    reject(new Error(errbuffer.trim()));
                    return;
                }
                resolve(buffer);
            });
    
            arpscan.on('error', err => {
                reject(new Error(err));
            });
        });
    }

    splitRule(str) {
        // Split rule on spaces but keep text in quotes
        return Array.from(str.matchAll(/[^"\s]+|"([^"]*)"/g), ([a,b]) => b || a) 
    }
}
module.exports = Iptables;
